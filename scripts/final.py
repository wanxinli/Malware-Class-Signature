from PyQt5 import QtWidgets
from sklearn.linear_model import (LinearRegression, Ridge, 
                                  Lasso, RandomizedLasso)

from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import RandomForestRegressor
import numpy as np
from minepy import MINE

#import sys 
from sklearn.preprocessing import Imputer
import warnings



warnings.filterwarnings("ignore")
def rank_to_dict(ranks, names, order=1):
            minmax = MinMaxScaler()
            data = np.matrix([ranks]).T
            data = Imputer().fit_transform(data)
            x_data = order*data
            ranks = minmax.fit_transform(x_data.T[0])
            ranks = list(map(lambda x: round(x, 7), ranks))
            
            return dict(zip(names, ranks ))

class HelloPython(QtWidgets.QWidget):
    def __init__(self, parent=None):
        super(HelloPython, self).__init__(parent)
        helloLabel = QtWidgets.QLabel("Choose a ranking algorithm:") 
        mainLayout = QtWidgets.QGridLayout()
        mainLayout.addWidget(helloLabel, 0, 1) 
        
        mtext = QtWidgets.QTextEdit("")
        mtext.setReadOnly(True)
        mtext.setFixedHeight(500)
        mainLayout.addWidget(mtext, 8,1)
        
        #X = np.genfromtxt("clustered_all_data.txt", delimiter= ",")
        #Y = np.genfromtxt("01_label.txt")
        X = np.genfromtxt(sys.argv[1], delimiter= ",")
        Y = np.genfromtxt(sys.argv[2])
        ranks = {}
        names = ["feature%s" % i for i in range(X.shape[1])]           
             
        
        alg = QtWidgets.QRadioButton('1')
        alg1Label = QtWidgets.QLabel("Linear Regression")
        alg.toggled.connect(lambda:self.buttonstate(alg, X, Y, ranks, names, mtext))
        mainLayout.addWidget(alg, 1, 0)
        mainLayout.addWidget(alg1Label, 1, 1)
        
        alg = QtWidgets.QRadioButton('2')
        alg2Label = QtWidgets.QLabel("Ridge method")
        #if alg.isChecked():
        alg.toggled.connect(lambda:self.buttonstate(alg, X, Y, ranks, names, mtext))
            
        mainLayout.addWidget(alg, 2, 0)
        mainLayout.addWidget(alg2Label, 2, 1)
        
        alg = QtWidgets.QRadioButton('3')
        alg3Label = QtWidgets.QLabel("Lasso algorithm")
        alg.toggled.connect(lambda: self.buttonstate(alg, X, Y, ranks, names, mtext))
        mainLayout.addWidget(alg, 3, 0)
        mainLayout.addWidget(alg3Label, 3, 1)
        
        alg = QtWidgets.QRadioButton('4')
        alg4Label = QtWidgets.QLabel("Stability algorithm (Randomised Lasso)")
        alg.toggled.connect(lambda: self.buttonstate(alg, X, Y, ranks, names, mtext))
        mainLayout.addWidget(alg, 4, 0)
        mainLayout.addWidget(alg4Label, 4, 1)
        
        alg = QtWidgets.QRadioButton('5')
        alg5Label = QtWidgets.QLabel("MIC model")
        alg.toggled.connect(lambda: self.buttonstate(alg, X, Y, ranks, names, mtext))
        mainLayout.addWidget(alg, 5, 0)
        mainLayout.addWidget(alg5Label, 5, 1)
        
        alg = QtWidgets.QRadioButton('6')
        alg6Label = QtWidgets.QLabel("Random Forest")
        alg.toggled.connect(lambda: self.buttonstate(alg, X, Y, ranks, names, mtext))
        mainLayout.addWidget(alg, 6, 0)
        mainLayout.addWidget(alg6Label, 6, 1)
        
        alg = QtWidgets.QRadioButton('7')
        alg7Label = QtWidgets.QLabel("Correlation algorithm")
        alg.toggled.connect(lambda: self.buttonstate(alg, X, Y, ranks, names, mtext))
        mainLayout.addWidget(alg, 7, 0)
        mainLayout.addWidget(alg7Label, 7, 1)
        
  
        self.setLayout(mainLayout)
        self.setWindowTitle("Feature ranking widget")     
        self.show()
               
        
        
    
    def buttonstate(self,alg, X, Y, ranks, names, mtext):
        
        alg = self.sender()
        if  alg.isChecked():
                        
                if alg.text() == '1':
                    mtext.clear()
                    lr = LinearRegression(normalize=True)
                    lr.fit(X, Y)
                    ranks["Linear reg"] = rank_to_dict( np.abs(lr.coef_), names)
                    w, h = 2, X.shape[1];
                    sortingList = [[0 for x in range(w)] for y in range(h)] 
                    for i in range(X.shape[1]) :
                        sortingList[i][0] = i
                        sortingList[i][1] = round(ranks['Linear reg']['feature'+str(i)],9);
                    #sort array by value   
                    sortingList.sort(key=lambda x: x[1], reverse = True)  
                    
                    #sort array by value    
                    for i in range(X.shape[1]):
                        # mtext.append(str(i))
                        mtext.append('feature '+ str(sortingList[i][0]) +":  "+ str(sortingList[i][1]))
        
                        
                if alg.text() == '2':
                    mtext.clear()
                    ridge = Ridge(alpha=7)
                    ridge.fit(X, Y)
                    ranks["Ridge"] = rank_to_dict(np.abs(ridge.coef_), names)
                    w, h = 2, X.shape[1];
                    sortingList = [[0 for x in range(w)] for y in range(h)] 
                    for i in range(X.shape[1]) :
                        # mtext.append(str(i))
                        sortingList[i][0] = i
                        sortingList[i][1] = round(ranks['Ridge']['feature'+str(i)],9);
                    #sort array by value   
                    sortingList.sort(key=lambda x: x[1], reverse = True)  
                    
                    #sort array by value    
                    for i in range(X.shape[1]):
                        # mtext.append(str(i))
                        mtext.append('feature '+ str(sortingList[i][0]) +":  "+ str(sortingList[i][1]))
                          
            
                if alg.text() == '3':
                    mtext.clear()
                    lasso = Lasso(alpha=.5)
                    lasso.fit(X, Y)
                    ranks["Lasso"] = rank_to_dict(np.abs(lasso.coef_), names)
                    w, h = 2, X.shape[1];
                    sortingList = [[0 for x in range(w)] for y in range(h)]  
                    for i in range(X.shape[1]) :
                        # mtext.append(str(i))
                        sortingList[i][0] = i
                        sortingList[i][1] = round(ranks['Lasso']['feature'+str(i)],9);
                    #sort array by value   
                    sortingList.sort(key=lambda x: x[1], reverse = True)
                    
                    for i in range(X.shape[1]):
                        # mtext.append(str(i))
                        mtext.append('feature '+ str(sortingList[i][0]) +":  "+ str(sortingList[i][1]))
     
                if alg.text() == '4':
                    mtext.clear()
                    rlasso = RandomizedLasso(alpha=0.4)
                    rlasso.fit(X, Y)
                    ranks["Stability"] = rank_to_dict(np.abs(rlasso.scores_), names)
                    w, h = 2, X.shape[1];
                    sortingList = [[0 for x in range(w)] for y in range(h)] 
                    for i in range(X.shape[1]) :
                        # mtext.append(str(i))
                        sortingList[i][0] = i
                        sortingList[i][1] = round(ranks['Stability']['feature'+str(i)],9);
                    #sort array by value   
                    sortingList.sort(key=lambda x: x[1], reverse = True)  
                    
                    #sort array by value    
                    for i in range(X.shape[1]):
                        # mtext.append(str(i))
                        mtext.append('feature '+ str(sortingList[i][0]) +":  "+ str(sortingList[i][1]))
                        
                if alg.text() == '5':
                    mtext.clear()
                    mine = MINE()
                    mic_scores = []
                    for i in range(X.shape[1]):
                        mine.compute_score(X[:,i], Y)
                        m = mine.mic()
                        mic_scores.append(m)
          
                    ranks["MIC"] = rank_to_dict(mic_scores, names) 
                    w, h = 2, X.shape[1];
                    sortingList = [[0 for x in range(w)] for y in range(h)] 
                    for i in range(X.shape[1]) :
                        # mtext.append(str(i))
                        sortingList[i][0] = i
                        sortingList[i][1] = round(ranks['MIC']['feature'+str(i)],9);
                    #sort array by value   
                    sortingList.sort(key=lambda x: x[1], reverse = True)  
                    
                    #sort array by value    
                    for i in range(X.shape[1]):
                        # mtext.append(str(i))
                        mtext.append('feature '+ str(sortingList[i][0]) +":  "+ str(sortingList[i][1]))
     
                
        
                
                if alg.text() == '6':
                    mtext.clear()
                    rf = RandomForestRegressor()
                    rf.fit(X,Y)
                    ranks["RF"] = rank_to_dict(rf.feature_importances_, names)
                    w, h = 2, X.shape[1];
                    sortingList = [[0 for x in range(w)] for y in range(h)] 
                    for i in range(X.shape[1]) :
                        # mtext.append(str(i))
                        sortingList[i][0] = i
                        sortingList[i][1] = round(ranks['RF']['feature'+str(i)],9);
                    #sort array by value   
                    sortingList.sort(key=lambda x: x[1], reverse = True)  
                    
                    #sort array by value    
                    for i in range(X.shape[1]):
                        # mtext.append(str(i))
                        mtext.append('feature '+ str(sortingList[i][0]) +":  "+ str(sortingList[i][1]))
     
         
                
                        
                if alg.text() == '7':
                    mtext.clear()
                    f, pval  = f_regression(X, Y, center=True)
                    ranks["Corr."] = rank_to_dict(f, names)
                    w, h = 2, X.shape[1];
                    sortingList = [[0 for x in range(w)] for y in range(h)] 
                    for i in range(X.shape[1]) :
                        # mtext.append(str(i))
                        sortingList[i][0] = i
                        sortingList[i][1] = round(ranks['Corr.']['feature'+str(i)],9);
                    #sort array by value   
                    sortingList.sort(key=lambda x: x[1], reverse = True)  
                    
                    #sort array by value    
                    for i in range(X.shape[1]):
                        # mtext.append(str(i))
                        mtext.append('feature '+ str(sortingList[i][0]) +":  "+ str(sortingList[i][1]))

if __name__ == '__main__':
    import sys
    
    #sys.argv[0] = "clustered_all_data.txt"
    #sys.argv[1] = "01_label.txt"
    app = QtWidgets.QApplication(sys.argv)
    
    
 
    helloPythonWidget = HelloPython()
    #helloPythonWidget.show()
    sys.exit(app.exec_())
 
    